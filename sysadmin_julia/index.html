<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script src="/libs/lunr/lunr.min.js"></script> <script src="/libs/lunr/lunr_index.js"></script> <script src="/libs/lunr/lunrclient.min.js"></script> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=stylesheet  href="/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/assets/favicon.png"> <title>Admin: How to provide Julia to users?</title> <style> .content {max-width: 60rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <h1><a href="/">Julia On HPC Clusters</a></h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by the Julia HPC community</div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9; margin-bottom: 1.2cm;"> <a class="sidebar-nav-item " href="/"><b>Welcome</b></a> <br> <div class=course-section >For Users</div> <a class="sidebar-nav-item " href="/user_gettingstarted/">Getting started</a> <a class="sidebar-nav-item " href="/user_vscode/">Visual Studio Code on HPC Clusters</a> <a class="sidebar-nav-item " href="/user_faq/">FAQ</a> <a class="sidebar-nav-item " href="/user_hpcprofiling/">HPC profiling tools</a> <a class="sidebar-nav-item " href="/user_hpcsystems/">HPC systems with Julia support</a> <div class=course-section >For System Admins</div> <a class="sidebar-nav-item active" href="/sysadmin_julia/">How to provide Julia to users?</a> </nav> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/search/index.html"> </form> <br> <br> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=admin_how_to_provide_julia_to_users ><a href="#admin_how_to_provide_julia_to_users" class=header-anchor >Admin: How to provide Julia to users?</a></h1> <p><hr /> </p> <p><a id=content  class=anchor ></a> <strong>Content</strong></p> <div class=franklin-toc ><ol><li><a href="#providing_julia_itself">Providing Julia itself</a><li><a href="#dont_provide_packages">Don&#39;t provide packages</a><li><a href="#providing_global_package_preferences">Providing global package preferences</a><ol><li><a href="#example_mpijl_and_cudajl">Example: MPI.jl and CUDA.jl</a><li><a href="#providing_everything_in_form_of_a_lmod_module">Providing everything in form of a Lmod module</a><li><a href="#checking_that_things_work_es_expected">Checking that things work es expected</a></ol><li><a href="#supporting_visual_studio_code">Supporting Visual Studio Code</a><li><a href="#potentially_useful_resources">Potentially useful resources</a></ol></div> <hr /> <h2 id=providing_julia_itself ><a href="#providing_julia_itself" class=header-anchor >Providing Julia itself</a></h2> <p>It is generally best to just provide the regular, pre-built Julia binaries from <a href="https://julialang.org/downloads/">https://julialang.org/downloads/</a>. They work and are efficient.</p> <p>You might be tempted to build Julia from source but this is almost never necessary or advantageous &#40;and can be cumbersome&#41;. The reason is pretty simple: Julia is a compiler in itself and user code is therefore barely influenced by how you compiled Julia. Hence, unless you know exactly what you&#39;re doing and have a good reason in mind, the pre-built binaries are the way to go.</p> <p><a href="#content">â¤´ <em><strong>back to Content</strong></em></a></p> <h2 id=dont_provide_packages ><a href="#dont_provide_packages" class=header-anchor >Don&#39;t provide packages</a></h2> <p>We strongly recommend against trying to provide Julia packages &#40;e.g. MPI.jl or CUDA.jl&#41; in a central fashion. There are a few important technical reasons but the two most important reasons to <strong>not</strong> do it are conceptual</p> <ol> <li><p>It conflicts with the idea of local, self-contained Julia environments.</p> <li><p>Packages evolve too quickly &#40;i.e. your central depot is out of date pretty quickly&#41;.</p> </ol> <p><strong>Short explanation:</strong> To have people use your centrally provided version of a package you would have to instruct them to not add that package to their &#40;local&#41; Julia environment as otherwise they&#39;ll very&#40;&#33;&#41; likely get a different version of the package and will end up not using your central version to begin with. To make <code>using PackageX</code> still work, you would then have to adjust <code>JULIA_LOAD_PATH</code> appropriately. However, not only doesn&#39;t the user not get the version of <code>PackageX</code> that they potentially want/need, the local <code>Project.toml</code>/<code>Manifest.toml</code> would not even contain <code>PackageX</code> and therefore severely undermine self-containedness and reproducibility - one of the nicest properties of Julia projects.</p> <p>Generally speaking, there is also little reason to provide regular Julia packages in a central fashion in the first place. After all, most of them don&#39;t take up that much disk space and a little bit of redundancy is acceptable on modern HPC clusters. In this regard, note that all packages only get installed <strong>once per user</strong> - and not per project as is the case for python - since Julia installs packages to a user-central depot and reuses them across projects.</p> <p><a href="#content">â¤´ <em><strong>back to Content</strong></em></a></p> <h2 id=providing_global_package_preferences ><a href="#providing_global_package_preferences" class=header-anchor >Providing global package preferences</a></h2> <p>What you might want to do is to globally override binary dependencies of Julia packages, so-called <a href="https://pkgdocs.julialang.org/v1/artifacts/">Julia artifacts</a> &#40;<a href="https://github.com/JuliaBinaryWrappers">JLLs</a>&#41;, such that users automatically get redirected to system binaries under the hood. This is especially relevant if vendor specific binaries &#40;e.g. a Cray MPI library&#41; are the only ones that function properly on the HPC cluster. Below we describe how to realize this by overriding package <a href="https://github.com/JuliaPackaging/Preferences.jl">preferences</a>. However, note that JLLs have the big advantage that they are convenient and work nicely together. You should hence only override preferences if there is a good reason for it.</p> <h3 id=example_mpijl_and_cudajl ><a href="#example_mpijl_and_cudajl" class=header-anchor >Example: MPI.jl and CUDA.jl</a></h3> <p>In this example we show how to make MPI.jl automatically use a system OpenMPI installation as well as make CUDA.jl use a system CUDA installation. The two steps are pretty straightforward:</p> <ol> <li><p>Create a global <code>Project.toml</code> that sets the preferences of the target packages.</p> <li><p>Append the path to the global <code>Project.toml</code> to <code>JULIA_LOAD_PATH</code> &#40;for all users&#41;.</p> </ol> <p>According to the documentation of MPI.jl &#40;<a href="https://juliaparallel.org/MPI.jl/stable/configuration/#Notes-to-HPC-cluster-administrators">relevant section</a>&#41; and CUDA.jl &#40;<a href="https://cuda.juliagpu.org/stable/installation/overview/#Using-a-local-CUDA">relevant section</a>&#41; the preferences that we need to modify are actually not in MPI.jl or CUDA.jl but rather in MPIPreferences.jl and CUDA&#95;Runtime&#95;jll.jl. We thus create a <code>Project.toml</code> like below:</p> <div class=note ><div class=title >ðŸ’¡ Note</div> <div class=messg >Tip: To obtain the correct preferences blocks you can use <code>MPIPreferences.use_system_binary&#40;&#41;</code> and <code>CUDA.set_runtime_version&#33;&#40;v&quot;11.7&quot;; local_toolkit&#61;true&#41;</code> respectively. This will create the relevant blocks in a <code>LocalPreferences.toml</code> file. The only thing you need to adjust is the block header, e.g. <code>MPIPreferences</code> -&gt; <code>preferences.MPIPreferences</code>.</div></div> <pre><code class="julia hljs">[extras]
MPIPreferences = <span class=hljs-string >&quot;3da0fdf6-3ccc-4f1b-acd9-58baa6c99267&quot;</span>
CUDA_Runtime_jll = <span class=hljs-string >&quot;76a88914-d11a-5bdc-97e0-2f5a05c973a2&quot;</span>

[preferences.MPIPreferences]
_format = <span class=hljs-string >&quot;1.0&quot;</span>
abi = <span class=hljs-string >&quot;OpenMPI&quot;</span>
binary = <span class=hljs-string >&quot;system&quot;</span>
libmpi = <span class=hljs-string >&quot;libmpi&quot;</span>
mpiexec = <span class=hljs-string >&quot;mpiexec&quot;</span>

[preferences.CUDA_Runtime_jll]
<span class=hljs-keyword >local</span> = <span class=hljs-string >&quot;true&quot;</span>
version = <span class=hljs-string >&quot;11.7&quot;</span></code></pre> <p>The only thing we then have to do is to append the path to this file to the <code>JULIA_LOAD_PATH</code>. The way to do it is as follows: <code>export JULIA_LOAD_PATH&#61;:/path/to/projectoml/</code>. Note the critical colon &#40;<code>:</code>&#41; here which implies <em>appending</em> rather than overwriting.</p> <h3 id=providing_everything_in_form_of_a_lmod_module ><a href="#providing_everything_in_form_of_a_lmod_module" class=header-anchor >Providing everything in form of a Lmod module</a></h3> <p>Since every user should get the modified <code>JULIA_LOAD_PATH</code> above, the environment variable should best be set directly in the Lmod module that also provides the Julia binaries as well as the MPI and CUDA installations we&#39;re pointing to. This way, any user who loads the module and then adds MPI.jl and CUDA.jl to one of their environments &#40;i.e. <code>&#93; add MPI CUDA</code>&#41; will automatically use the system MPI and system CUDA under the hood without having to do anything else. That is to say that the global preference system is <em>opt-out</em> &#40;the user can always override the global preferences with local preferences, e.g. via a <code>LocalPreferences.toml</code>, on a per-project basis&#41;.</p> <p><strong>Side note:</strong> Speaking of setting environment variables in the module file, it is recommended to set <code>JULIA_CUDA_MEMORY_POOL&#61;none</code> to disable the <a href="https://cuda.juliagpu.org/stable/usage/memory/#Memory-pool">memory pool</a> that CUDA.jl uses by default. This is particularly advisable when you use a system CUDA due to incompatibility with certain CUDA APIs.</p> <div class=note ><div class=title >ðŸ’¡ Note</div> <div class=messg >You might want to check out <a href="https://git.uni-paderborn.de/pc2-public/juliahpc_installer">JuliaHPC_Installer</a> which is a Julia script that automates the installation of a new Julia version via easybuild, including the global <code>Project.toml</code> setup discussed above. It is used on <a href="https://pc2.uni-paderborn.de/hpc-services/available-systems/noctua2">Noctua 2</a> at <a href="https://pc2.uni-paderborn.de/">PC2</a>. However, it is currently not portable out of the box &#40;since e.g. paths are hardcoded&#41;.</div></div> <h3 id=checking_that_things_work_es_expected ><a href="#checking_that_things_work_es_expected" class=header-anchor >Checking that things work es expected</a></h3> <p>To check that things are working you can <code>&#93; add MPI CUDA</code> and then run <code>CUDA.runtime_version&#40;&#41;</code> and <code>CUDA.versioninfo&#40;&#41;</code> which should give the version of the system CUDA and say &quot;local installation&quot;, respectively:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> CUDA

julia&gt; CUDA.runtime_version()
<span class=hljs-string >v&quot;11.7.0&quot;</span>

julia&gt; CUDA.versioninfo()
CUDA runtime <span class=hljs-number >11.7</span>, <span class=hljs-keyword >local</span> installation
CUDA driver <span class=hljs-number >12.1</span>
NVIDIA driver <span class=hljs-number >530.30</span><span class=hljs-number >.2</span>

[...]</code></pre> <p>Similarly, you can use <code>MPI.identify_implementation&#40;&#41;</code> and <code>MPI.MPIPreferences.binary</code> which should show the version of the system MPI as well as &quot;system&quot;, respectively:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> MPI

julia&gt; MPI.identify_implementation()
(<span class=hljs-string >&quot;OpenMPI&quot;</span>, <span class=hljs-string >v&quot;4.1.4&quot;</span>)

julia&gt; MPI.MPIPreferences.binary
<span class=hljs-string >&quot;system&quot;</span></code></pre> <p><a href="#content">â¤´ <em><strong>back to Content</strong></em></a></p> <h2 id=supporting_visual_studio_code ><a href="#supporting_visual_studio_code" class=header-anchor >Supporting Visual Studio Code</a></h2> <p>One of the key features of Julia is that it is inherently dynamic. Users might thus likely want to use Julia interactively and remotely on your HPC cluster. One way to do so is through <a href="https://code.visualstudio.com/">VS Code</a>, specifically via the <a href="https://www.julia-vscode.org/">Julia VS Code extension</a>. The extension really only needs one thing to work: the <code>julia</code> binary. However, if you provide Julia as a module, this binary is only available if this module is already loaded &#40;which it isn&#39;t if the user just connects to the cluster via <a href="https://marketplace.visualstudio.com/items?itemName&#61;ms-vscode-remote.remote-ssh">Remote - SSH</a>&#41;.</p> <p>A good solution to this problem is to provide a script &#40;e.g. called <code>julia_vscode</code>&#41;, which serves as an in-place replacement for <code>julia</code> but takes care of the module loading first &#40;see below&#41;.</p> <pre><code class="shell hljs"><span class="hljs-meta prompt_">#</span><span class=language-bash >!/bin/bash</span>
<span class="hljs-meta prompt_"># </span><span class=language-bash >Example script `julia_vscode` used on Noctua 2 at PC2</span>
<span class="hljs-meta prompt_"># </span><span class=language-bash >The Julia module used below is called <span class=hljs-string >&quot;lang/JuliaHPC&quot;</span></span>
<span class="hljs-meta prompt_"># </span><span class=language-bash >Author: Carsten Bauer</span>
<span class="hljs-meta prompt_">
# </span><span class=language-bash >------ Set up the module system (HPC system specific) ------</span>
export MODULEPATH=/etc/modulefiles:/usr/share/modulefiles || :
source /usr/share/lmod/lmod/init/profile
if [ -f &quot;/opt/software/pc2/lmod/modules/DefaultModules.lua&quot; ];then
        export MODULEPATH=&quot;$MODULEPATH:/opt/software/pc2/lmod/modules&quot;
        export LMOD_SYSTEM_DEFAULT_MODULES=&quot;DefaultModules&quot;
else
        if [ -f &quot;/usr/share/modulefiles/StdEnv.lua&quot; ];then
                export LMOD_SYSTEM_DEFAULT_MODULES=&quot;StdEnv&quot;
        fi
fi
module --initial_load restore
<span class="hljs-meta prompt_"># </span><span class=language-bash >------------------------------------------------------------</span>
<span class="hljs-meta prompt_">
# </span><span class=language-bash >Load a specific Julia module</span>
module load lang/JuliaHPC/1.9.1-foss-2022a-CUDA-11.7.0
<span class="hljs-meta prompt_">
# </span><span class=language-bash >Start Julia and pass on all command-line arguments</span>
exec julia &quot;${@}&quot;</code></pre> <p>At PC2 such a script is provided for every Julia version / Julia module &#40;see <a href="https://git.uni-paderborn.de/pc2-public/juliahpc_installer">JuliaHPC_Installer</a>&#41; as well as a generic one that only contains <code>module load lang/JuliaHPC</code> &#40;without a version number&#41; and thus always loads the latest Julia module.</p> <p><a href="#content">â¤´ <em><strong>back to Content</strong></em></a></p> <h2 id=potentially_useful_resources ><a href="#potentially_useful_resources" class=header-anchor >Potentially useful resources</a></h2> <ul> <li><p><a href="https://git.uni-paderborn.de/pc2-public/juliahpc_installer">JuliaHPC_Installer</a> by <a href="https://carstenbauer.eu">Carsten Bauer</a>: a Julia script that automates the installation of a new Julia version via easybuild, including the global <code>Project.toml</code> setup discussed above. It is used on <a href="https://pc2.uni-paderborn.de/hpc-services/available-systems/noctua2">Noctua 2</a> at <a href="https://pc2.uni-paderborn.de/">PC2</a>. However, it is currently not portable out of the box &#40;since e.g. paths are hardcoded&#41;.</p> <li><p><a href="https://github.com/jblaschke">Johannes Blaschke</a> provides <a href="https://gitlab.blaschke.science/nersc/julia/-/tree/main/modulefiles">scripts and templates</a> to set up modules file for Julia on some of NERSC&#39;s systems &#40;warning: potentially outdated?&#41;</p> <li><p><a href="https://github.com/omlins">Samuel Omlin</a> and colleagues from CSCS provide their <a href="https://github.com/eth-cscs/production/tree/master/easybuild/easyconfigs/j/Julia">Easybuild configuration files</a> used for Piz Daint &#40;warning: potentially outdated?&#41;</p> </ul> <p><a href="#content">â¤´ <em><strong>back to Content</strong></em></a></p> <div class=page-foot > <div class=copyright > <a href="https://github.com/carstenbauer/JuliaOnHPCClusters/"><b>Edit this page on <img class=github-logo  src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></b></a><br> Last modified: July 12, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div>