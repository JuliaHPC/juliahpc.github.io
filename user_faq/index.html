<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script src="/libs/lunr/lunr.min.js"></script> <script src="/libs/lunr/lunr_index.js"></script> <script src="/libs/lunr/lunrclient.min.js"></script> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=stylesheet  href="/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 1%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/assets/favicon.png"> <title>FAQ</title> <style> .content {max-width: 60rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <h1><a href="/">Julia On HPC Clusters</a></h1> <img src="/assets/juliahpc_logo.png" width=100px> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9; margin-bottom: 1.2cm;"> <a class="sidebar-nav-item " href="/"><b>Welcome</b></a> <br> <div class=course-section >For Users</div> <a class="sidebar-nav-item " href="/user_gettingstarted/">Getting started</a> <a class="sidebar-nav-item " href="/user_vscode/">Visual Studio Code</a> <a class="sidebar-nav-item " href="/user_hpcprofiling/">Profiling tools</a> <a class="sidebar-nav-item " href="/user_hpcsystems/">Systems with Julia support</a> <a class="sidebar-nav-item active" href="/user_faq/">FAQ</a> <div class=course-section >For System Admins</div> <a class="sidebar-nav-item " href="/sysadmin_julia/">How to provide Julia to users?</a> </nav> <!-- <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/search/index.html"> </form> --> <div style="line-height:18px; font-size: 18px; opacity: 0.85"><a href="https://github.com/JuliaHPC/juliahpc.github.io/blob/main/website/LICENSE.md">© Carsten Bauer</a></div> <br> <div class=github-link > <a href="https://github.com/JuliaHPC/juliahpc.github.io"> <svg xmlns="http://www.w3.org/2000/svg" height=28px  fill=currentColor  viewBox="0 0 496 512"> <!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --> <path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" /> </svg> </a> </div> <br> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=faq ><a href="#faq" class=header-anchor >FAQ</a></h1> <p><a id=content  class=anchor ></a> <strong>Content</strong></p> <div class=franklin-toc ><ol><li><a href="#julia_isnt_available_on_my_cluster_can_i_install_and_use_it_without_root_privileges">Julia isn&#39;t available on my cluster. Can I install and use it &#40;without root privileges&#41;?</a><li><a href="#should_i_compile_julia_from_source">Should I compile Julia from source?</a><li><a href="#julia_installed_from_juliaup_not_found_in_a_non-interactive_job">Julia installed from juliaup not found in a non-interactive job</a><li><a href="#where_should_i_put_the_julia_depot">Where should I put the Julia depot?</a><li><a href="#how_should_i_start_julia_within_a_job_script">How should I start Julia within a job script?</a><li><a href="#how_can_i_force_julia_to_compile_code_for_a_heterogeneous_cluster">How can I force Julia to compile code for a heterogeneous cluster?</a><li><a href="#should_i_use_distributedjl_or_mpijl_for_large-scale_parallelism">Should I use Distributed.jl or MPI.jl for large-scale parallelism?</a><li><a href="#should_i_use_julia_artifacts_jlls_or_system_software">Should I use Julia artifacts &#40;JLLs&#41; or system software?</a><li><a href="#how_to_cope_with_a_large_number_of_mpi_processes_accessing_the_same_julia_depot">How to cope with a large number of MPI processes accessing the same Julia depot?</a><li><a href="#how_to_avoid_ld_library_path_issues">How to avoid <code>LD_LIBRARY_PATH</code> issues?</a><li><a href="#julia_unexpectedly_killed_for_exceeding_the_requested_memory_limit">Julia unexpectedly killed for exceeding the requested memory limit</a><li><a href="#i_get_memory-related_issues_when_using_cudajl_on_a_hpc_cluster">I get memory-related issues when using CUDA.jl on a HPC cluster</a><li><a href="#precompilation_on_a_login_node_fails_resource_temporarily_unavailable">Precompilation on a login node fails &#40;<code>Resource temporarily unavailable</code>&#41;</a><li><a href="#can_i_precompile_gpu_code_on_a_login_node_without_a_gpu">Can I precompile GPU code on a login node without a GPU?</a></ol></div> <hr /> <h2 id=julia_isnt_available_on_my_cluster_can_i_install_and_use_it_without_root_privileges ><a href="#julia_isnt_available_on_my_cluster_can_i_install_and_use_it_without_root_privileges" class=header-anchor >Julia isn&#39;t available on my cluster. Can I install and use it &#40;without root privileges&#41;?</a></h2> <p>Yes, absolutely. You <strong>do not</strong> need root privileges to install Julia and its packages. However, often times it&#39;s better to put the Julia depot - the place where packages, artifacts, and other things will be stored - on the parallel file system rather than into <code>&#36;HOME</code>. See the <a href="/user_gettingstarted/">Getting Started</a> section for more information.</p> <h2 id=should_i_compile_julia_from_source ><a href="#should_i_compile_julia_from_source" class=header-anchor >Should I compile Julia from source?</a></h2> <p><strong>No, you should not.</strong> Use the pre-built binaries from the website or, preferably, a corresponding Lmod module provided by the cluster admins. Compiling Julia from source will generally <strong>not</strong> improve the performance of your code &#40;Julia is a compiler in itself&#41; but may very well be cumbersome. Unless you know what you&#39;re doing and have a very good reason &#40;e.g. creating a debug build with flags like <code>USE_INTEL_JITEVENTS&#61;1</code>&#41; you should not compile Julia yourself.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=julia_installed_from_juliaup_not_found_in_a_non-interactive_job ><a href="#julia_installed_from_juliaup_not_found_in_a_non-interactive_job" class=header-anchor >Julia installed from juliaup not found in a non-interactive job</a></h2> <p>The installation path of the <code>julia</code> executable will be added to your <code>~/.bashrc</code> by <a href="https://github.com/JuliaLang/juliaup">juliaup</a>. If the job scheduler does not load <code>.bashrc</code> in non-interactive jobs, you must use the full path to <code>julia</code> in your job script. You can find out the full path by starting the Julia REPL and typing <code>Sys.BINDIR</code>. By default, it should be <code>~/.juliaup/bin/julia</code>.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=where_should_i_put_the_julia_depot ><a href="#where_should_i_put_the_julia_depot" class=header-anchor >Where should I put the Julia depot?</a></h2> <p>Ideally, you should set <code>JULIA_DEPOT_PATH</code> to point to a place with the following properties:</p> <ul> <li><p>good &#40;parallel&#41; I/O</p> <li><p>no tight quotas</p> <li><p>read and write access</p> <li><p>no automatic deletion of unused files &#40;or otherwise you have to find a workaround&#41;</p> </ul> <p>As a rule of thumb: Put the Julia depot on the parallel file system &#40;typically <code>&#36;SCRATCH</code>&#41;.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=how_should_i_start_julia_within_a_job_script ><a href="#how_should_i_start_julia_within_a_job_script" class=header-anchor >How should I start Julia within a job script?</a></h2> <p>Assuming that SLURM is used on your HPC cluster, you should generally start Julia under <code>srun</code>, e.g. <code>srun julia --project mycode.jl</code>. This is especially important if your code is MPI-parallel, in which case <code>srun</code> is a replacement for <code>mpirun</code>/<code>mpiexec</code>, but also recommended for serial code &#40;there are at least <a href="https://stackoverflow.com/a/53640511/2365675">a few reasons</a>&#41;.</p> <p>Note that you can use the slim <code>mpiexecjl</code> wrapper from <code>MPI.jl</code> to use the &quot;correct&quot; MPI driver automatically.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=how_can_i_force_julia_to_compile_code_for_a_heterogeneous_cluster ><a href="#how_can_i_force_julia_to_compile_code_for_a_heterogeneous_cluster" class=header-anchor >How can I force Julia to compile code for a heterogeneous cluster?</a></h2> <p>Set <a href="https://docs.julialang.org/en/v1.10-dev/manual/environment-variables/#JULIA_CPU_TARGET"><code>JULIA_CPU_TARGET</code></a> to a value that is generic enough to cover all the types of CPUs that you&#39;re targeting. You can get the CPU target name for the current system with <code>Sys.CPU_NAME</code>.</p> <p><strong>Example:</strong> <code>JULIA_CPU_TARGET&#61;&quot;generic;skylake-avx512,clone_all;znver2,clone_all&quot;</code>.</p> <p>This compiles all functions &#40;<code>clone_all</code>&#41; for Intel Skylake &#40;<code>skylake-avx512</code>&#41;, AMD Zen 2 &#40;<code>znver2</code>&#41;, and a generic fallback &#40;<code>generic</code>&#41;.</p> <p>For more information, see <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_CPU_TARGET">this section of the Julia documentation</a> and <a href="https://docs.julialang.org/en/v1/devdocs/sysimg/#Specifying-multiple-system-image-targets">this section of the developer documentation</a>.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=should_i_use_distributedjl_or_mpijl_for_large-scale_parallelism ><a href="#should_i_use_distributedjl_or_mpijl_for_large-scale_parallelism" class=header-anchor >Should I use Distributed.jl or MPI.jl for large-scale parallelism?</a></h2> <p>While the Distributed standard library provides some convenient tools and has its use cases you should generally use MPI.jl to scale your code up &#40;e.g. to thousands of compute nodes&#41;. Not only is MPI the established standard for distributed computing in any programming language, it also makes use of fast interconnects in HPC clusters &#40;which the Distributed standard library currently doesn&#39;t&#41;.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=should_i_use_julia_artifacts_jlls_or_system_software ><a href="#should_i_use_julia_artifacts_jlls_or_system_software" class=header-anchor >Should I use Julia artifacts &#40;JLLs&#41; or system software?</a></h2> <p>If JLLs work fine for you then use them. JLLs have the big advantage that they are convenient and, in many cases, &quot;just work&quot; out of the box. System software can &#40;but doesn&#39;t necessarily&#41; give better performance but overriding the relevant bits of JLLs can be cumbersome. Generally speaking, we recommend to only manually replace JLL libraries by system software if JLLs don&#39;t work &#40;e.g. if a vendor specific MPI is required&#41;. However, in such a case it would be even better to nudge the HPC admins and make this setup permanent and generally available in form of a Julia Lmod module.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=how_to_cope_with_a_large_number_of_mpi_processes_accessing_the_same_julia_depot ><a href="#how_to_cope_with_a_large_number_of_mpi_processes_accessing_the_same_julia_depot" class=header-anchor >How to cope with a large number of MPI processes accessing the same Julia depot?</a></h2> <p>In a distributed computing scenario with, e.g., multiple thousands of Julia &#40;MPI&#41; processes, accessing the same Julia depot on a shared file system - when loading packages and precompiled cache files on <code>using PackageX</code> - can become &#40;very&#41; time consuming. A workaround is to bundle up the Julia depot &#40;e.g. as a <code>.tar.gz</code>&#41;, distribute it to the local node storage &#40;if available&#41; or local memory &#40;often times mounted as <code>/tmp</code>&#41; of all assigned compute nodes, and then set the <code>JULIA_DEPOT_PATH</code> accordingly.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=how_to_avoid_ld_library_path_issues ><a href="#how_to_avoid_ld_library_path_issues" class=header-anchor >How to avoid <code>LD_LIBRARY_PATH</code> issues?</a></h2> <p>When using Julia on a system that uses an environment-variable based module system &#40;such as <a href="https://github.com/cea-hpc/modules">modules</a> or <a href="https://github.com/TACC/Lmod">Lmod</a>&#41;, the <code>LD_LIBRARY_PATH</code> variable might be filled with entries pointing to different packages and libraries. This might &#40;or might not&#41; lead to issues stemming from Julia loading libraries other than the ones packaged with it. If you encounter such problems, make sure that Julia&#39;s <code>lib</code> directory is always the <em>first</em> directory in <code>LD_LIBRARY_PATH</code>.</p> <p>One possibility to achieve this is to create a wrapper shell script that modifies <code>LD_LIBRARY_PATH</code> before calling the Julia executable. Inspired by a <a href="https://github.com/UCL-RITS/rcps-buildscripts/blob/04b2e2ccfe7e195fd0396b572e9f8ff426b37f0e/files/julia/julia.sh">script</a> from UCL&#39;s <a href="https://github.com/owainkenwayucl">Owain Kenway</a>:</p> <pre><code class="shell hljs"><span class="hljs-meta prompt_">#</span><span class=language-bash >!/usr/bin/env bash</span>
<span class="hljs-meta prompt_">
# </span><span class=language-bash >This wrapper makes sure the julia binary distributions picks up the GCC</span>
<span class="hljs-meta prompt_"># </span><span class=language-bash >libraries provided with it correctly meaning that it does not rely on</span>
<span class="hljs-meta prompt_"># </span><span class=language-bash >the gcc-libs version.</span>
<span class="hljs-meta prompt_">
# </span><span class=language-bash >Dr Owain Kenway, 20th of July, 2021</span>
<span class="hljs-meta prompt_"># </span><span class=language-bash >Source: https://github.com/UCL-RITS/rcps-buildscripts/blob/04b2e2ccfe7e195fd0396b572e9f8ff426b37f0e/files/julia/julia.sh</span>

location=$(readlink -f $0)
directory=$(readlink -f $(dirname ${location})/..)

export LD_LIBRARY_PATH=${directory}/lib/julia:${LD_LIBRARY_PATH}
exec ${directory}/bin/julia &quot;$@&quot;</code></pre> <p>Note that using <code>readlink</code> might not be optimal from a performance perspective if used in a massively parallel environment. Alternatively, hard-code the Julia path or set an environment variable accordingly.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=julia_unexpectedly_killed_for_exceeding_the_requested_memory_limit ><a href="#julia_unexpectedly_killed_for_exceeding_the_requested_memory_limit" class=header-anchor >Julia unexpectedly killed for exceeding the requested memory limit</a></h2> <p>If a job has non-exclusive access to a node and has a memory limit that is lower than the total memory of the node, set the <code>--heap-size-hint</code> command line option to an appropriate value when starting Julia in the job script, e.g. <code>julia --heap-size-hint&#61;4G my_script.jl</code> if you have requested a memory limit of 4G for running <code>my_script.jl</code>. This communicates the memory limit to Julia&#39;s garbage collector to enable more aggressive garbage collection when the memory limit is approached.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=i_get_memory-related_issues_when_using_cudajl_on_a_hpc_cluster ><a href="#i_get_memory-related_issues_when_using_cudajl_on_a_hpc_cluster" class=header-anchor >I get memory-related issues when using CUDA.jl on a HPC cluster</a></h2> <p>Try setting <code>JULIA_CUDA_MEMORY_POOL&#61;none</code> &#40;see the <a href="https://cuda.juliagpu.org/stable/usage/memory/#Memory-pool">CUDA.jl documentation</a> for more information&#41;.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=precompilation_on_a_login_node_fails_resource_temporarily_unavailable ><a href="#precompilation_on_a_login_node_fails_resource_temporarily_unavailable" class=header-anchor >Precompilation on a login node fails &#40;<code>Resource temporarily unavailable</code>&#41;</a></h2> <p>By default, Julia uses many parallel tasks during precompilation. On the login nodes of some HPC clusters, parallel processes might be subject to resource restrictions. In these cases, you might want to set <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_NUM_PRECOMPILE_TASKS"><code>JULIA_NUM_PRECOMPILE_TASKS</code></a> to a low value, e.g. <code>export JULIA_NUM_PRECOMPILE_TASKS&#61;1</code> &#40;single task&#41;.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <h2 id=can_i_precompile_gpu_code_on_a_login_node_without_a_gpu ><a href="#can_i_precompile_gpu_code_on_a_login_node_without_a_gpu" class=header-anchor >Can I precompile GPU code on a login node without a GPU?</a></h2> <p>Yes, at least for CUDA.jl. See <a href="https://cuda.juliagpu.org/stable/installation/overview/#Precompiling-CUDA.jl-without-CUDA">this part</a> of the CUDA.jl documentation.</p> <p><a href="#content">⤴ <em><strong>back to Content</strong></em></a></p> <div class=page-foot > <div class=copyright > <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> C. Bauer. Last modified: January 07, 2025. <br>Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div>